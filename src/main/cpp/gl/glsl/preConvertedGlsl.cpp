//
// Created by BZLZHH on 2025/2/11.
//

#include "preConvertedGlsl.h"

#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

#define DEBUG 0

const char* preConvertedGlsl1Original = R"(#version 430 core
// Generated by glsl-transformer
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;
struct iris_FogParameters {
vec4 color;
float density;
float start;
float end;
float scale;
};
iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0f / (iris_FogEnd - iris_FogStart));
float LinearToCurve(float c) {
return pow(c, 0.25f);
}
float CurveToLinear(float c) {
c = c * c;
return c * c;
}
vec3 LinearToCurve(vec3 c) {
return pow(c, vec3(0.25f));
}
vec3 CurveToLinear(vec3 c) {
c = c * c;
return c * c;
}
vec2 OctWrap(vec2 v) {
return (1.0f - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}
float D_Walter(float NdotH, float roughness) {
float roughness2 = roughness * roughness;
float k = NdotH * NdotH * (roughness2 - 1.0f) + 1.0f;
return roughness2 / (3.14159265359f * k * k);
}
float F_Schlick(float VdotH, float f0, float f90) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}
vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (1.0f - f0) * (VdotH2 * VdotH2 * VdotH);
}
float V_Schlick(float NdotL, float NdotV, float roughness) {
float k = roughness * 0.5f;
return NdotL / ((NdotL * (1.0f - k) + k) * (NdotV * (1.0f - k) + k) + 1.0E-20f);
}
float bayer2(vec2 a) {
a = floor(a);
return fract(dot(a, vec2(0.5f, a.y * 0.75f)));
}
float bayer4(vec2 a) {
return bayer2(0.5f * a) * 0.25f + bayer2(a);
}
float bayer8(vec2 a) {
return bayer4(0.5f * a) * 0.25f + bayer2(a);
}
float bayer16(vec2 a) {
return bayer4(0.25f * a) * 0.0625f + bayer4(a);
}
const ivec3 workGroups = ivec3(24, 24, 24);
layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
layout(rgba16) uniform writeonly image3D img_voxelData3D;
shared uint isOccupied_8;
shared uint isOccupied_4[8];
shared uint isOccupied_2[64];
uniform sampler2D shadowcolor1;
const float shadowDistance = 192.0f;
const float voxelDistance = 96.0f;
const float shadowSize = 3968.0f;
const float shadowPixelSize = 1.0f / 3968.0f;
const float shadowWidth = 2048.0f;
const float voxelWidth = 1920.0f;
const float shadowRatio = 16.0f / 31.0f;
vec2 VoxelTexel_From_VoxelCoord(vec3 voxelCoord) {
voxelCoord.x += voxelCoord.y * 192.0f;
voxelCoord.y = floor(voxelCoord.x / 1920.0f);
voxelCoord.xz += voxelCoord.y * vec2(-1920.0f, 192.0f);
return voxelCoord.xz;
}
void main() {
int id_4 = int((gl_LocalInvocationID.x >> 2u) + (gl_LocalInvocationID.y >> 2u) * 2u + (gl_LocalInvocationID.z >> 2u) * 4u);
int id_2 = int((gl_LocalInvocationID.x >> 1u) + (gl_LocalInvocationID.y >> 1u) * 4u + (gl_LocalInvocationID.z >> 2u) * 16u);
isOccupied_8 = 0u;
isOccupied_4[id_4] = 0u;
isOccupied_2[id_2] = 0u;
barrier();
ivec3 drawTexel = ivec3(gl_GlobalInvocationID.xyz);
ivec2 voxelTexel = ivec2(VoxelTexel_From_VoxelCoord(vec3(drawTexel)));
vec4 voxelData = texelFetch(shadowcolor1, voxelTexel, 0);
uint occupied = uint(voxelData.z < 1.0f);
uint occupied_8 = atomicMax(isOccupied_8, occupied);
barrier();
if (isOccupied_8 == 0u) {
voxelData.z = 0.91f;
} else {
uint occupied_4 = atomicMax(isOccupied_4[id_4], occupied);
barrier();
if (isOccupied_4[id_4] == 0u) {
voxelData.z = 0.71f;
} else {
uint occupied_2 = atomicMax(isOccupied_2[id_2], occupied);
barrier();
if (isOccupied_2[id_2] == 0u) voxelData.z = 0.61f;
}
}
imageStore(img_voxelData3D, drawTexel, voxelData);
}
)";
const char* preConvertedGlsl1Converted = R"(#version 320 es
precision highp float;
precision highp int;
precision highp image3D;

uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;

float LinearToCurve(float c) {
    return pow(c, 0.25);
}

float CurveToLinear(float c) {
    c = c * c;
    return c * c;
}

vec3 LinearToCurve(vec3 c) {
    return pow(c, vec3(0.25));
}

vec3 CurveToLinear(vec3 c) {
    c = c * c;
    return c * c;
}

vec2 OctWrap(vec2 v) {
    return (1.0 - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}

float D_Walter(float NdotH, float roughness) {
    float roughness2 = roughness * roughness;
    float k = NdotH * NdotH * (roughness2 - 1.0) + 1.0;
    return roughness2 / (3.14159265359 * k * k);
}

float F_Schlick(float VdotH, float f0, float f90) {
    VdotH = 1.0 - VdotH;
    float VdotH2 = VdotH * VdotH;
    return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}

vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
    VdotH = 1.0 - VdotH;
    float VdotH2 = VdotH * VdotH;
    return f0 + (1.0 - f0) * (VdotH2 * VdotH2 * VdotH);
}

float V_Schlick(float NdotL, float NdotV, float roughness) {
    float k = roughness * 0.5;
    return NdotL / ((NdotL * (1.0 - k) + k) * (NdotV * (1.0 - k) + k) + 1.0e-20);
}

float bayer2(vec2 a) {
    a = floor(a);
    return fract(dot(a, vec2(0.5, a.y * 0.75)));
}

float bayer4(vec2 a) {
    return bayer2(0.5 * a) * 0.25 + bayer2(a);
}

float bayer8(vec2 a) {
    return bayer4(0.5 * a) * 0.25 + bayer2(a);
}

float bayer16(vec2 a) {
    return bayer4(0.25 * a) * 0.0625 + bayer4(a);
}

const ivec3 workGroups = ivec3(24, 24, 24);
layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
layout(rgba16f) uniform writeonly image3D img_voxelData3D;

shared uint isOccupied_8;
shared uint isOccupied_4[8];
shared uint isOccupied_2[64];

uniform highp sampler2D shadowcolor1;

const float shadowDistance = 192.0;
const float voxelDistance = 96.0;
const float shadowSize = 3968.0;
const float shadowPixelSize = 1.0 / 3968.0;
const float shadowWidth = 2048.0;
const float voxelWidth = 1920.0;
const float shadowRatio = 16.0 / 31.0;

vec2 VoxelTexel_From_VoxelCoord(vec3 voxelCoord) {
    voxelCoord.x += voxelCoord.y * 192.0;
    voxelCoord.y = floor(voxelCoord.x / 1920.0);
    voxelCoord.xz += voxelCoord.y * vec2(-1920.0, 192.0);
    return voxelCoord.xz;
}

shared uint occupiedFlags_8[512];
shared uint occupiedFlags_4[8][64];
shared uint occupiedFlags_2[64][16];

void main() {
    int id_4 = int((int(gl_LocalInvocationID.x) >> 2) + (int(gl_LocalInvocationID.y) >> 2) * 2 + (int(gl_LocalInvocationID.z) >> 2) * 4);
    int id_2 = int((int(gl_LocalInvocationID.x) >> 1) + (int(gl_LocalInvocationID.y) >> 1) * 4 + (int(gl_LocalInvocationID.z) >> 2) * 16);



    // Initialize shared variables
    isOccupied_8 = 0u;
    for (int i = 0; i < 8; ++i) isOccupied_4[i] = 0u;
    for (int i = 0; i < 64; ++i) isOccupied_2[i] = 0u;
    barrier();

    ivec3 drawTexel = ivec3(gl_GlobalInvocationID.xyz);
    ivec2 voxelTexel = ivec2(VoxelTexel_From_VoxelCoord(vec3(drawTexel)));
    vec4 voxelData = texelFetch(shadowcolor1, voxelTexel, 0);
    uint occupied = uint(voxelData.z < 1.0);

    // Process isOccupied_8
    uint localIndex = gl_LocalInvocationID.x + gl_LocalInvocationID.y * 8u + gl_LocalInvocationID.z * 8u * 8u;
    occupiedFlags_8[localIndex] = occupied;
    barrier();
    if (localIndex == 0u) {
        uint anyOccupied = 0u;
        for (int i = 0; i < 512; ++i) anyOccupied |= occupiedFlags_8[i];
        isOccupied_8 = anyOccupied;
    }
    barrier();

    if (isOccupied_8 == 0u) {
        voxelData.z = 0.91;
    } else {
        // Process isOccupied_4
        uint group_x = gl_LocalInvocationID.x % 4u;
        uint group_y = gl_LocalInvocationID.y % 4u;
        uint group_z = gl_LocalInvocationID.z % 4u;
        uint group_index = group_x + group_y * 4u + group_z * 16u;
        occupiedFlags_4[id_4][group_index] = occupied;
        barrier();
        if (group_index == 0u) {
            uint anyOccupied = 0u;
            for (int i = 0; i < 64; ++i) anyOccupied |= occupiedFlags_4[id_4][i];
            isOccupied_4[id_4] = anyOccupied;
        }
        barrier();

        if (isOccupied_4[id_4] == 0u) {
            voxelData.z = 0.71;
        } else {
            // Process isOccupied_2
            uint group_x2 = gl_LocalInvocationID.x % 2u;
            uint group_y2 = gl_LocalInvocationID.y % 2u;
            uint group_z2 = gl_LocalInvocationID.z % 4u;
            uint group_index2 = group_x2 + group_y2 * 2u + group_z2 * 4u;
            occupiedFlags_2[id_2][group_index2] = occupied;
            barrier();
            if (group_index2 == 0u) {
                uint anyOccupied = 0u;
                for (int i = 0; i < 16; ++i) anyOccupied |= occupiedFlags_2[id_2][i];
                isOccupied_2[id_2] = anyOccupied;
            }
            barrier();

            if (isOccupied_2[id_2] == 0u) voxelData.z = 0.61;
        }
    }

    imageStore(img_voxelData3D, drawTexel, voxelData);
}
)";

const char* preConvertedGlsl2Original = R"(#version 430 core
// Generated by glsl-transformer
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;
struct iris_FogParameters {
vec4 color;
float density;
float start;
float end;
float scale;
};
iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0f / (iris_FogEnd - iris_FogStart));
uniform int heldItemId;
uniform int heldBlockLightValue;
uniform int heldItemId2;
uniform int heldBlockLightValue2;
uniform int worldTime;
uniform int frameCounter;
uniform float frameTime;
uniform float frameTimeCounter;
uniform float sunAngle;
uniform float aspectRatio;
uniform float viewWidth;
uniform float viewHeight;
uniform float near;
uniform float far;
uniform vec3 cameraPosition;
uniform vec3 cameraPositionFract;
uniform vec3 cameraPositionToPrevious;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferPreviousModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferPreviousProjection;
uniform mat4 shadowProjection;
uniform mat4 shadowModelViewInverse;
uniform float wetness;
uniform ivec2 eyeBrightnessSmooth;
uniform int isEyeInWater;
uniform float nightVision;
uniform float blindness;
uniform int hideGUI;
uniform float darknessFactor;
uniform float darknessLightFactor;
uniform vec2 taaJitter;
uniform vec2 taaJitterToPrevious;
uniform vec2 screenSize;
uniform vec2 pixelSize;
uniform vec3 shadowModelView0;
uniform vec3 shadowModelView1;
uniform vec3 shadowModelView2;
uniform float eyeBrightnessSmoothCurved;
uniform float eyeBrightnessZeroSmooth;
uniform float eyeSnowySmooth;
uniform float eyeNoPrecipitationSmooth;
uniform float eyeRxSmooth;
uniform float eyeRySmooth;
uniform float isSneakingSmooth;
uniform sampler2D colortex0;
uniform sampler2D colortex1;
uniform sampler2D colortex2;
uniform sampler2D colortex3;
uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform sampler2D colortex8;
uniform sampler2D colortex9;
uniform sampler2D colortex10;
uniform sampler2D colortex12;
uniform sampler2D depthtex0;
uniform sampler2D depthtex1;
uniform sampler2D depthtex2;
uniform sampler2D noisetex;
uniform sampler2D colortex13;
uniform sampler2D colortex14;
uniform sampler2D colortex15;
float LinearToCurve(float c) {
return pow(c, 0.25f);
}
float CurveToLinear(float c) {
c = c * c;
return c * c;
}
vec3 LinearToCurve(vec3 c) {
return pow(c, vec3(0.25f));
}
vec3 CurveToLinear(vec3 c) {
c = c * c;
return c * c;
}
vec2 OctWrap(vec2 v) {
return (1.0f - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}
float D_Walter(float NdotH, float roughness) {
float roughness2 = roughness * roughness;
float k = NdotH * NdotH * (roughness2 - 1.0f) + 1.0f;
return roughness2 / (3.14159265359f * k * k);
}
float F_Schlick(float VdotH, float f0, float f90) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}
vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (1.0f - f0) * (VdotH2 * VdotH2 * VdotH);
}
float V_Schlick(float NdotL, float NdotV, float roughness) {
float k = roughness * 0.5f;
return NdotL / ((NdotL * (1.0f - k) + k) * (NdotV * (1.0f - k) + k) + 1.0E-20f);
}
float bayer2(vec2 a) {
a = floor(a);
return fract(dot(a, vec2(0.5f, a.y * 0.75f)));
}
float bayer4(vec2 a) {
return bayer2(0.5f * a) * 0.25f + bayer2(a);
}
float bayer8(vec2 a) {
return bayer4(0.5f * a) * 0.25f + bayer2(a);
}
float bayer16(vec2 a) {
return bayer4(0.25f * a) * 0.0625f + bayer4(a);
}
layout(local_size_x = 16, local_size_y = 8) in;
layout(rgba16) uniform image2D colorimg2;
const vec2 workGroupsRender = vec2(0.5f, 0.5f);
shared uvec2 sampleColor[333];
vec2 sampleCoord(int id, vec2 groupTexelOrigin) {
float row = float(id) / 35.0f;
float p = floor(row);
float f = row - p;
float rowOffset = clamp(f * 2.0E10f - 1.0E10f, 0.0f, 1.0f);
vec2 offset = vec2(f * 70.0f - rowOffset * 35.0f, p * 2.0f + rowOffset);
vec2 sampleCoord = groupTexelOrigin + offset;
sampleCoord = clamp(sampleCoord, vec2(1.5f), screenSize - 1.5f);
return sampleCoord * pixelSize;
}
void main() {
vec2 groupTexelOrigin = vec2(gl_WorkGroupID.xy) * vec2(32.0f, 16.0f) - 0.5f;
int id = int(gl_LocalInvocationIndex);
vec3 sampleData = textureLod(colortex1, sampleCoord(id, groupTexelOrigin), 0.0f).rgb;
sampleColor[id] = uvec2(packHalf2x16(sampleData.xy), floatBitsToUint(sampleData.z));
id += 128;
sampleData = textureLod(colortex1, sampleCoord(id, groupTexelOrigin), 0.0f).rgb;
sampleColor[id] = uvec2(packHalf2x16(sampleData.xy), floatBitsToUint(sampleData.z));
id += 128;
if (id < 333) {
sampleData = textureLod(colortex1, sampleCoord(id, groupTexelOrigin), 0.0f).rgb;
sampleColor[id] = uvec2(packHalf2x16(sampleData.xy), floatBitsToUint(sampleData.z));
}
barrier();
int wid = int(gl_LocalInvocationID.x + gl_LocalInvocationID.y * 35u);
uvec2 writeData = sampleColor[wid];
vec3 blur = vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.03125f;
writeData = sampleColor[wid + 1];
blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.0625f;
writeData = sampleColor[wid + 2];
blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.03125f;
writeData = sampleColor[wid + 18];
blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.125f;
writeData = sampleColor[wid + 19];
blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.125f;
writeData = sampleColor[wid + 35];
blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.0625f;
writeData = sampleColor[wid + 36];
blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.03125f;
writeData = sampleColor[wid + 37];
blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.0625f;
writeData = sampleColor[wid + 53];
blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.125f;
writeData = sampleColor[wid + 54];
blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.125f;
writeData = sampleColor[wid + 70];
blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.03125f;
writeData = sampleColor[wid + 71];
blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.0625f;
writeData = sampleColor[wid + 72];
blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y).x) * 0.03125f;
ivec2 drawTexel = ivec2(gl_GlobalInvocationID.xy);
if (all(lessThan(drawTexel, ivec2(screenSize * 0.5f)))) {
drawTexel.y += int(screenSize.y * 0.5f);
imageStore(colorimg2, drawTexel, vec4(blur, 0.0f));
}
}
)";

const char* preConvertedGlsl2Converted = R"(#version 320 es
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp image2D;

uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;

uniform int heldItemId;
uniform int heldBlockLightValue;
uniform int heldItemId2;
uniform int heldBlockLightValue2;
uniform int worldTime;
uniform int frameCounter;
uniform float frameTime;
uniform float frameTimeCounter;
uniform float sunAngle;
uniform float aspectRatio;
uniform float viewWidth;
uniform float viewHeight;
uniform float near;
uniform float far;
uniform vec3 cameraPosition;
uniform vec3 cameraPositionFract;
uniform vec3 cameraPositionToPrevious;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferPreviousModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferPreviousProjection;
uniform mat4 shadowProjection;
uniform mat4 shadowModelViewInverse;
uniform float wetness;
uniform ivec2 eyeBrightnessSmooth;
uniform int isEyeInWater;
uniform float nightVision;
uniform float blindness;
uniform int hideGUI;
uniform float darknessFactor;
uniform float darknessLightFactor;
uniform vec2 taaJitter;
uniform vec2 taaJitterToPrevious;
uniform vec2 screenSize;
uniform vec2 pixelSize;
uniform vec3 shadowModelView0;
uniform vec3 shadowModelView1;
uniform vec3 shadowModelView2;
uniform float eyeBrightnessSmoothCurved;
uniform float eyeBrightnessZeroSmooth;
uniform float eyeSnowySmooth;
uniform float eyeNoPrecipitationSmooth;
uniform float eyeRxSmooth;
uniform float eyeRySmooth;
uniform float isSneakingSmooth;

uniform sampler2D colortex0;
uniform sampler2D colortex1;
uniform sampler2D colortex2;
uniform sampler2D colortex3;
uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform sampler2D colortex8;
uniform sampler2D colortex9;
uniform sampler2D colortex10;
uniform sampler2D colortex12;
uniform sampler2D depthtex0;
uniform sampler2D depthtex1;
uniform sampler2D depthtex2;
uniform sampler2D noisetex;
uniform sampler2D colortex13;
uniform sampler2D colortex14;
uniform sampler2D colortex15;

float LinearToCurve(float c) {
    return pow(c, 0.25);
}

float CurveToLinear(float c) {
    c = c * c;
    return c * c;
}

vec3 LinearToCurve(vec3 c) {
    return pow(c, vec3(0.25));
}

vec3 CurveToLinear(vec3 c) {
    c = c * c;
    return c * c;
}

vec2 OctWrap(vec2 v) {
    return (1.0 - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}

float D_Walter(float NdotH, float roughness) {
    float roughness2 = roughness * roughness;
    float k = NdotH * NdotH * (roughness2 - 1.0) + 1.0;
    return roughness2 / (3.14159265359 * k * k);
}

float F_Schlick(float VdotH, float f0, float f90) {
    VdotH = 1.0 - VdotH;
    float VdotH2 = VdotH * VdotH;
    return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}

vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
    VdotH = 1.0 - VdotH;
    float VdotH2 = VdotH * VdotH;
    return f0 + (1.0 - f0) * (VdotH2 * VdotH2 * VdotH);
}

float V_Schlick(float NdotL, float NdotV, float roughness) {
    float k = roughness * 0.5;
    return NdotL / ((NdotL * (1.0 - k) + k) * (NdotV * (1.0 - k) + k) + 1.0e-20);
}

float bayer2(vec2 a) {
    a = floor(a);
    return fract(dot(a, vec2(0.5, a.y * 0.75)));
}

float bayer4(vec2 a) {
    return bayer2(0.5 * a) * 0.25 + bayer2(a);
}

float bayer8(vec2 a) {
    return bayer4(0.5 * a) * 0.25 + bayer2(a);
}

float bayer16(vec2 a) {
    return bayer4(0.25 * a) * 0.0625 + bayer4(a);
}

layout(local_size_x = 16, local_size_y = 8) in;
writeonly layout(rgba16f) uniform highp image2D colorimg2;

shared uvec2 sampleColor[333];

vec2 sampleCoord(int id, vec2 groupTexelOrigin) {
    float row = float(id) / 35.0;
    float p = floor(row);
    float f = row - p;
    float rowOffset = clamp(f * 2.0e10 - 1.0e10, 0.0, 1.0);
    vec2 offset = vec2(f * 70.0 - rowOffset * 35.0, p * 2.0 + rowOffset);
    vec2 sampleCoord = groupTexelOrigin + offset;
    sampleCoord = clamp(sampleCoord, vec2(1.5), screenSize - 1.5);
    return sampleCoord * pixelSize;
}

void main() {
    vec2 groupTexelOrigin = vec2(gl_WorkGroupID.xy) * vec2(32.0, 16.0) - 0.5;
    int id = int(gl_LocalInvocationIndex);
    
    vec3 sampleData = textureLod(colortex1, sampleCoord(id, groupTexelOrigin), 0.0).rgb;
    sampleColor[id] = uvec2(packHalf2x16(sampleData.xy), floatBitsToUint(sampleData.z));
    
    id += 128;
    sampleData = textureLod(colortex1, sampleCoord(id, groupTexelOrigin), 0.0).rgb;
    sampleColor[id] = uvec2(packHalf2x16(sampleData.xy), floatBitsToUint(sampleData.z));
    
    id += 128;
    if (id < 333) {
        sampleData = textureLod(colortex1, sampleCoord(id, groupTexelOrigin), 0.0).rgb;
        sampleColor[id] = uvec2(packHalf2x16(sampleData.xy), floatBitsToUint(sampleData.z));
    }
    
    barrier();
    
    int wid = int(gl_LocalInvocationID.x + gl_LocalInvocationID.y * 35u);
    uvec2 writeData = sampleColor[wid];
    vec3 blur = vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.03125;
    
    writeData = sampleColor[wid + 1];
    blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.0625;
    
    writeData = sampleColor[wid + 2];
    blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.03125;
    
    writeData = sampleColor[wid + 18];
    blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.125;
    
    writeData = sampleColor[wid + 19];
    blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.125;
    
    writeData = sampleColor[wid + 35];
    blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.0625;
    
    writeData = sampleColor[wid + 36];
    blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.03125;
    
    writeData = sampleColor[wid + 37];
    blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.0625;
    
    writeData = sampleColor[wid + 53];
    blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.125;
    
    writeData = sampleColor[wid + 54];
    blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.125;
    
    writeData = sampleColor[wid + 70];
    blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.03125;
    
    writeData = sampleColor[wid + 71];
    blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.0625;
    
    writeData = sampleColor[wid + 72];
    blur += vec3(unpackHalf2x16(writeData.x), uintBitsToFloat(writeData.y)) * 0.03125;

    ivec2 drawTexel = ivec2(gl_GlobalInvocationID.xy);
    if (all(lessThan(drawTexel, ivec2(screenSize * 0.5)))) {
        drawTexel.y += int(screenSize.y * 0.5);
        imageStore(colorimg2, drawTexel, vec4(blur, 0.0));
    }
}
)";

const char* preConvertedGlsl3Original = R"(#version 430 core
// Generated by glsl-transformer
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;
struct iris_FogParameters {
vec4 color;
float density;
float start;
float end;
float scale;
};
iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0f / (iris_FogEnd - iris_FogStart));
uniform int heldItemId;
uniform int heldBlockLightValue;
uniform int heldItemId2;
uniform int heldBlockLightValue2;
uniform int worldTime;
uniform int frameCounter;
uniform float frameTime;
uniform float frameTimeCounter;
uniform float sunAngle;
uniform float aspectRatio;
uniform float viewWidth;
uniform float viewHeight;
uniform float near;
uniform float far;
uniform vec3 cameraPosition;
uniform vec3 cameraPositionFract;
uniform vec3 cameraPositionToPrevious;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferPreviousModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferPreviousProjection;
uniform mat4 shadowProjection;
uniform mat4 shadowModelViewInverse;
uniform float wetness;
uniform ivec2 eyeBrightnessSmooth;
uniform int isEyeInWater;
uniform float nightVision;
uniform float blindness;
uniform int hideGUI;
uniform float darknessFactor;
uniform float darknessLightFactor;
uniform vec2 taaJitter;
uniform vec2 taaJitterToPrevious;
uniform vec2 screenSize;
uniform vec2 pixelSize;
uniform vec3 shadowModelView0;
uniform vec3 shadowModelView1;
uniform vec3 shadowModelView2;
uniform float eyeBrightnessSmoothCurved;
uniform float eyeBrightnessZeroSmooth;
uniform float eyeSnowySmooth;
uniform float eyeNoPrecipitationSmooth;
uniform float eyeRxSmooth;
uniform float eyeRySmooth;
uniform float isSneakingSmooth;
uniform sampler2D colortex0;
uniform sampler2D colortex1;
uniform sampler2D colortex2;
uniform sampler2D colortex3;
uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform sampler2D colortex8;
uniform sampler2D colortex9;
uniform sampler2D colortex10;
uniform sampler2D colortex12;
uniform sampler2D depthtex0;
uniform sampler2D depthtex1;
uniform sampler2D depthtex2;
uniform sampler2D noisetex;
uniform sampler2D colortex13;
uniform sampler2D colortex14;
uniform sampler2D colortex15;
float LinearToCurve(float c) {
return pow(c, 0.25f);
}
float CurveToLinear(float c) {
c = c * c;
return c * c;
}
vec3 LinearToCurve(vec3 c) {
return pow(c, vec3(0.25f));
}
vec3 CurveToLinear(vec3 c) {
c = c * c;
return c * c;
}
vec2 OctWrap(vec2 v) {
return (1.0f - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}
float D_Walter(float NdotH, float roughness) {
float roughness2 = roughness * roughness;
float k = NdotH * NdotH * (roughness2 - 1.0f) + 1.0f;
return roughness2 / (3.14159265359f * k * k);
}
float F_Schlick(float VdotH, float f0, float f90) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}
vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (1.0f - f0) * (VdotH2 * VdotH2 * VdotH);
}
float V_Schlick(float NdotL, float NdotV, float roughness) {
float k = roughness * 0.5f;
return NdotL / ((NdotL * (1.0f - k) + k) * (NdotV * (1.0f - k) + k) + 1.0E-20f);
}
float bayer2(vec2 a) {
a = floor(a);
return fract(dot(a, vec2(0.5f, a.y * 0.75f)));
}
float bayer4(vec2 a) {
return bayer2(0.5f * a) * 0.25f + bayer2(a);
}
float bayer8(vec2 a) {
return bayer4(0.5f * a) * 0.25f + bayer2(a);
}
float bayer16(vec2 a) {
return bayer4(0.25f * a) * 0.0625f + bayer4(a);
}
layout(local_size_x = 16, local_size_y = 8) in;
layout(rgba16) uniform image2D colorimg2;
const vec2 workGroupsRender = vec2(0.35f, 0.252f);
vec3 AxialGaussianBlurX(sampler2D texSampler, vec2 coord, float coordScale, vec2 sampleSize, const float alpha, const float steps) {
vec3 blur = vec3(0.0f);
float weights = 0.0f;
for (float i = -steps; i <= steps; i++) {
float sampleWeight = exp2(-i * i * alpha * 5.77f);
vec2 sampleCoord = coord;
sampleCoord.x += 2.0f / coordScale * pixelSize.x * i;
vec2 tCoord = sampleCoord;
sampleCoord = clamp(sampleCoord, vec2(0.0f), sampleSize);
sampleWeight *= float(tCoord == sampleCoord) + 1.0E-20f;
sampleCoord.x *= coordScale;
blur += textureLod(texSampler, sampleCoord, 0.0f).rgb * sampleWeight;
weights += sampleWeight;
}
return blur / weights;
}
void main() {
vec2 originSize = vec2(0.25f);
vec2 borderWidth = pixelSize;
const float intervalWidth = 3.0f;
vec2 border = originSize + borderWidth;
vec2 axis = vec2(1.0f, 0.0f);
vec3 blur = vec3(0.0f);
ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
texelCoord.x += int(screenSize.x * 0.25f);
texelCoord.y -= 1;
vec2 coord = (vec2(texelCoord) + 0.5f) * pixelSize;
bool draw = false;
coord.x -= originSize.x + pixelSize.x * intervalWidth;
originSize.x *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurX(colortex2, coord, 2.0f, originSize, 0.16f, 2.0f);
draw = true;
}
coord.x -= originSize.x + pixelSize.x * intervalWidth;
originSize.x *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurX(colortex2, coord, 4.0f, originSize, 0.035f, 5.0f);
draw = true;
}
coord.x -= originSize.x + pixelSize.x * intervalWidth;
originSize.x *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurX(colortex2, coord, 8.0f, originSize, 0.0085f, 12.0f);
draw = true;
}
coord.x -= originSize.x + pixelSize.x * intervalWidth;
originSize.x *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurX(colortex2, coord, 16.0f, originSize, 0.002f, 28.0f);
draw = true;
}
coord.x -= originSize.x + pixelSize.x * intervalWidth;
originSize.x *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurX(colortex2, coord, 32.0f, originSize, 5.0E-4f, 50.0f);
draw = true;
}
coord.x -= originSize.x + pixelSize.x * intervalWidth;
originSize.x *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurX(colortex2, coord, 64.0f, originSize, 1.5E-4f, 90.0f);
draw = true;
}
barrier();
if (draw) {
texelCoord.y += int(screenSize.y * 0.5f) + 1;
imageStore(colorimg2, texelCoord, vec4(blur, 0.0f));
}
})";

const char* preConvertedGlsl3Converted = R"(#version 320 es
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp image2D;

uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;

uniform int heldItemId;
uniform int heldBlockLightValue;
uniform int heldItemId2;
uniform int heldBlockLightValue2;
uniform int worldTime;
uniform int frameCounter;
uniform float frameTime;
uniform float frameTimeCounter;
uniform float sunAngle;
uniform float aspectRatio;
uniform float viewWidth;
uniform float viewHeight;
uniform float near;
uniform float far;
uniform vec3 cameraPosition;
uniform vec3 cameraPositionFract;
uniform vec3 cameraPositionToPrevious;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferPreviousModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferPreviousProjection;
uniform mat4 shadowProjection;
uniform mat4 shadowModelViewInverse;
uniform float wetness;
uniform ivec2 eyeBrightnessSmooth;
uniform int isEyeInWater;
uniform float nightVision;
uniform float blindness;
uniform int hideGUI;
uniform float darknessFactor;
uniform float darknessLightFactor;
uniform vec2 taaJitter;
uniform vec2 taaJitterToPrevious;
uniform vec2 screenSize;
uniform vec2 pixelSize;
uniform vec3 shadowModelView0;
uniform vec3 shadowModelView1;
uniform vec3 shadowModelView2;
uniform float eyeBrightnessSmoothCurved;
uniform float eyeBrightnessZeroSmooth;
uniform float eyeSnowySmooth;
uniform float eyeNoPrecipitationSmooth;
uniform float eyeRxSmooth;
uniform float eyeRySmooth;
uniform float isSneakingSmooth;

uniform sampler2D colortex0;
uniform sampler2D colortex1;
uniform sampler2D colortex2;
uniform sampler2D colortex3;
uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform sampler2D colortex8;
uniform sampler2D colortex9;
uniform sampler2D colortex10;
uniform sampler2D colortex12;
uniform sampler2D depthtex0;
uniform sampler2D depthtex1;
uniform sampler2D depthtex2;
uniform sampler2D noisetex;
uniform sampler2D colortex13;
uniform sampler2D colortex14;
uniform sampler2D colortex15;

float LinearToCurve(float c) {
    return pow(c, 0.25f);
}

float CurveToLinear(float c) {
    c = c * c;
    return c * c;
}

vec3 LinearToCurve(vec3 c) {
    return pow(c, vec3(0.25f));
}

vec3 CurveToLinear(vec3 c) {
    c = c * c;
    return c * c;
}

vec2 OctWrap(vec2 v) {
    return (1.0f - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}

float D_Walter(float NdotH, float roughness) {
    float roughness2 = roughness * roughness;
    float k = NdotH * NdotH * (roughness2 - 1.0f) + 1.0f;
    return roughness2 / (3.14159265359f * k * k);
}

float F_Schlick(float VdotH, float f0, float f90) {
    VdotH = 1.0f - VdotH;
    float VdotH2 = VdotH * VdotH;
    return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}

vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
    VdotH = 1.0f - VdotH;
    float VdotH2 = VdotH * VdotH;
    return f0 + (1.0f - f0) * (VdotH2 * VdotH2 * VdotH);
}

float V_Schlick(float NdotL, float NdotV, float roughness) {
    float k = roughness * 0.5f;
    return NdotL / ((NdotL * (1.0f - k) + k) * (NdotV * (1.0f - k) + k) + 1.0E-20f);
}

float bayer2(vec2 a) {
    a = floor(a);
    return fract(dot(a, vec2(0.5f, a.y * 0.75f)));
}

float bayer4(vec2 a) {
    return bayer2(0.5f * a) * 0.25f + bayer2(a);
}

float bayer8(vec2 a) {
    return bayer4(0.5f * a) * 0.25f + bayer2(a);
}

float bayer16(vec2 a) {
    return bayer4(0.25f * a) * 0.0625f + bayer4(a);
}

layout(local_size_x = 16, local_size_y = 8) in;
writeonly layout(rgba16f) uniform highp image2D colorimg2;

const vec2 workGroupsRender = vec2(0.35f, 0.252f);

vec3 AxialGaussianBlurX(sampler2D texSampler, vec2 coord, float coordScale, vec2 sampleSize, float alpha, float steps) {
    vec3 blur = vec3(0.0f);
    float weights = 0.0f;
    for(int i = int(-steps); i <= int(steps); i++) {
        float sampleWeight = exp2(-float(i) * float(i) * alpha * 5.77f);
        vec2 sampleCoord = coord;
        sampleCoord.x += 2.0f / coordScale * pixelSize.x * float(i);
        vec2 tCoord = sampleCoord;
        sampleCoord = clamp(sampleCoord, vec2(0.0f), sampleSize);
        sampleWeight *= float(all(equal(tCoord, sampleCoord))) + 1.0E-20f;
        sampleCoord.x *= coordScale;
        blur += textureLod(texSampler, sampleCoord, 0.0f).rgb * sampleWeight;
        weights += sampleWeight;
    }
    return blur / weights;
}

void main() {
    vec2 originSize = vec2(0.25f);
    vec2 borderWidth = pixelSize;
    const float intervalWidth = 3.0f;
    vec2 border = originSize + borderWidth;
    vec2 axis = vec2(1.0f, 0.0f);
    vec3 blur = vec3(0.0f);
    
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    texelCoord.x += int(screenSize.x * 0.25f);
    texelCoord.y -= 1;
    
    vec2 coord = (vec2(texelCoord) + 0.5f) * pixelSize;
    bool draw = false;

    // Cascade 1
    coord.x -= originSize.x + pixelSize.x * intervalWidth;
    originSize.x *= 0.5f;
    border = originSize + borderWidth;
    if(coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurX(colortex2, coord, 2.0f, originSize, 0.16f, 2.0f);
        draw = true;
    }

    // Cascade 2
    coord.x -= originSize.x + pixelSize.x * intervalWidth;
    originSize.x *= 0.5f;
    border = originSize + borderWidth;
    if(coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurX(colortex2, coord, 4.0f, originSize, 0.035f, 5.0f);
        draw = true;
    }

    // Cascade 3
    coord.x -= originSize.x + pixelSize.x * intervalWidth;
    originSize.x *= 0.5f;
    border = originSize + borderWidth;
    if(coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurX(colortex2, coord, 8.0f, originSize, 0.0085f, 12.0f);
        draw = true;
    }

    // Cascade 4
    coord.x -= originSize.x + pixelSize.x * intervalWidth;
    originSize.x *= 0.5f;
    border = originSize + borderWidth;
    if(coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurX(colortex2, coord, 16.0f, originSize, 0.002f, 28.0f);
        draw = true;
    }

    // Cascade 5
    coord.x -= originSize.x + pixelSize.x * intervalWidth;
    originSize.x *= 0.5f;
    border = originSize + borderWidth;
    if(coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurX(colortex2, coord, 32.0f, originSize, 5.0E-4f, 50.0f);
        draw = true;
    }

    // Cascade 6
    coord.x -= originSize.x + pixelSize.x * intervalWidth;
    originSize.x *= 0.5f;
    border = originSize + borderWidth;
    if(coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurX(colortex2, coord, 64.0f, originSize, 1.5E-4f, 90.0f);
        draw = true;
    }

    barrier();
    
    if(draw) {
        texelCoord.y += int(screenSize.y * 0.5f) + 1;
        imageStore(colorimg2, texelCoord, vec4(blur, 0.0f));
    }
}
)";

const char* preConvertedGlsl4Original = R"(#version 430 core
// Generated by glsl-transformer
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;
struct iris_FogParameters {
vec4 color;
float density;
float start;
float end;
float scale;
};
iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0f / (iris_FogEnd - iris_FogStart));
uniform int heldItemId;
uniform int heldBlockLightValue;
uniform int heldItemId2;
uniform int heldBlockLightValue2;
uniform int worldTime;
uniform int frameCounter;
uniform float frameTime;
uniform float frameTimeCounter;
uniform float sunAngle;
uniform float aspectRatio;
uniform float viewWidth;
uniform float viewHeight;
uniform float near;
uniform float far;
uniform vec3 cameraPosition;
uniform vec3 cameraPositionFract;
uniform vec3 cameraPositionToPrevious;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferPreviousModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferPreviousProjection;
uniform mat4 shadowProjection;
uniform mat4 shadowModelViewInverse;
uniform float wetness;
uniform ivec2 eyeBrightnessSmooth;
uniform int isEyeInWater;
uniform float nightVision;
uniform float blindness;
uniform int hideGUI;
uniform float darknessFactor;
uniform float darknessLightFactor;
uniform vec2 taaJitter;
uniform vec2 taaJitterToPrevious;
uniform vec2 screenSize;
uniform vec2 pixelSize;
uniform vec3 shadowModelView0;
uniform vec3 shadowModelView1;
uniform vec3 shadowModelView2;
uniform float eyeBrightnessSmoothCurved;
uniform float eyeBrightnessZeroSmooth;
uniform float eyeSnowySmooth;
uniform float eyeNoPrecipitationSmooth;
uniform float eyeRxSmooth;
uniform float eyeRySmooth;
uniform float isSneakingSmooth;
uniform sampler2D colortex0;
uniform sampler2D colortex1;
uniform sampler2D colortex2;
uniform sampler2D colortex3;
uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform sampler2D colortex8;
uniform sampler2D colortex9;
uniform sampler2D colortex10;
uniform sampler2D colortex12;
uniform sampler2D depthtex0;
uniform sampler2D depthtex1;
uniform sampler2D depthtex2;
uniform sampler2D noisetex;
uniform sampler2D colortex13;
uniform sampler2D colortex14;
uniform sampler2D colortex15;
float LinearToCurve(float c) {
return pow(c, 0.25f);
}
float CurveToLinear(float c) {
c = c * c;
return c * c;
}
vec3 LinearToCurve(vec3 c) {
return pow(c, vec3(0.25f));
}
vec3 CurveToLinear(vec3 c) {
c = c * c;
return c * c;
}
vec2 OctWrap(vec2 v) {
return (1.0f - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}
float D_Walter(float NdotH, float roughness) {
float roughness2 = roughness * roughness;
float k = NdotH * NdotH * (roughness2 - 1.0f) + 1.0f;
return roughness2 / (3.14159265359f * k * k);
}
float F_Schlick(float VdotH, float f0, float f90) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}
vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (1.0f - f0) * (VdotH2 * VdotH2 * VdotH);
}
float V_Schlick(float NdotL, float NdotV, float roughness) {
float k = roughness * 0.5f;
return NdotL / ((NdotL * (1.0f - k) + k) * (NdotV * (1.0f - k) + k) + 1.0E-20f);
}
float bayer2(vec2 a) {
a = floor(a);
return fract(dot(a, vec2(0.5f, a.y * 0.75f)));
}
float bayer4(vec2 a) {
return bayer2(0.5f * a) * 0.25f + bayer2(a);
}
float bayer8(vec2 a) {
return bayer4(0.5f * a) * 0.25f + bayer2(a);
}
float bayer16(vec2 a) {
return bayer4(0.25f * a) * 0.0625f + bayer4(a);
}
layout(local_size_x = 16, local_size_y = 8) in;
layout(rgba16) uniform image2D colorimg2;
const vec2 workGroupsRender = vec2(0.35f, 0.25f);
vec3 AxialGaussianBlurY(
sampler2D texSampler,
vec2 coord,
float coordScale,
float coordOffset,
float sampleOrigin,
vec2 sampleSize,
const float alpha,
const float steps
) {
vec3 blur = vec3(0.0f);
float weights = 0.0f;
for (float i = -steps; i <= steps; i++) {
float sampleWeight = exp2(-i * i * alpha * 5.77f);
vec2 sampleCoord = coord;
sampleCoord.y += 2.0f / coordScale * pixelSize.y * i;
vec2 tCoord = sampleCoord;
sampleCoord = clamp(sampleCoord, vec2(sampleOrigin, 0.0f), vec2(sampleOrigin + sampleSize.x, sampleSize.y));
sampleWeight *= float(tCoord == sampleCoord) + 1.0E-20f;
sampleCoord.y = sampleCoord.y * coordScale + coordOffset;
blur += textureLod(texSampler, sampleCoord, 0.0f).rgb * sampleWeight;
weights += sampleWeight;
}
return blur / weights;
}
void main() {
vec2 originSize = vec2(0.25f);
vec2 borderWidth = pixelSize;
const float intervalWidth = 3.0f;
vec2 border = originSize + borderWidth;
vec2 axis = vec2(0.0f, 1.0f);
vec3 blur = vec3(0.0f);
ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
texelCoord.x += int(screenSize.x * 0.25f);
vec2 texCoord = (vec2(texelCoord) + 0.5f) * pixelSize;
float coordOffset = (floor(screenSize.y * 0.5f) + 1.0f) * pixelSize.y;
vec2 coord = texCoord;
float currInterval = 0.0f;
float sampleOrigin = 0.0f;
currInterval = originSize.x + pixelSize.x * intervalWidth;
coord.x -= currInterval;
sampleOrigin += currInterval;
originSize *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurY(colortex2, texCoord, 2.0f, coordOffset, sampleOrigin, originSize, 0.16f, 2.0f);
}
currInterval = originSize.x + pixelSize.x * intervalWidth;
coord.x -= currInterval;
sampleOrigin += currInterval;
originSize *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurY(colortex2, texCoord, 4.0f, coordOffset, sampleOrigin, originSize, 0.035f, 5.0f);
}
currInterval = originSize.x + pixelSize.x * intervalWidth;
coord.x -= currInterval;
sampleOrigin += currInterval;
originSize *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurY(colortex2, texCoord, 8.0f, coordOffset, sampleOrigin, originSize, 0.0085f, 12.0f);
}
currInterval = originSize.x + pixelSize.x * intervalWidth;
coord.x -= currInterval;
sampleOrigin += currInterval;
originSize *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurY(colortex2, texCoord, 16.0f, coordOffset, sampleOrigin, originSize, 0.002f, 28.0f);
}
currInterval = originSize.x + pixelSize.x * intervalWidth;
coord.x -= currInterval;
sampleOrigin += currInterval;
originSize *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurY(colortex2, texCoord, 32.0f, coordOffset, sampleOrigin, originSize, 5.0E-4f, 50.0f);
}
currInterval = originSize.x + pixelSize.x * intervalWidth;
coord.x -= currInterval;
sampleOrigin += currInterval;
originSize *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurY(colortex2, texCoord, 64.0f, coordOffset, sampleOrigin, originSize, 1.5E-4f, 90.0f);
}
imageStore(colorimg2, texelCoord, vec4(blur, 0.0f));
})";

const char* preConvertedGlsl4Converted = R"(#version 320 es
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp image2D;

uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;

uniform int heldItemId;
uniform int heldBlockLightValue;
uniform int heldItemId2;
uniform int heldBlockLightValue2;
uniform int worldTime;
uniform int frameCounter;
uniform float frameTime;
uniform float frameTimeCounter;
uniform float sunAngle;
uniform float aspectRatio;
uniform float viewWidth;
uniform float viewHeight;
uniform float near;
uniform float far;
uniform vec3 cameraPosition;
uniform vec3 cameraPositionFract;
uniform vec3 cameraPositionToPrevious;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferPreviousModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferPreviousProjection;
uniform mat4 shadowProjection;
uniform mat4 shadowModelViewInverse;
uniform float wetness;
uniform ivec2 eyeBrightnessSmooth;
uniform int isEyeInWater;
uniform float nightVision;
uniform float blindness;
uniform int hideGUI;
uniform float darknessFactor;
uniform float darknessLightFactor;
uniform vec2 taaJitter;
uniform vec2 taaJitterToPrevious;
uniform vec2 screenSize;
uniform vec2 pixelSize;
uniform vec3 shadowModelView0;
uniform vec3 shadowModelView1;
uniform vec3 shadowModelView2;
uniform float eyeBrightnessSmoothCurved;
uniform float eyeBrightnessZeroSmooth;
uniform float eyeSnowySmooth;
uniform float eyeNoPrecipitationSmooth;
uniform float eyeRxSmooth;
uniform float eyeRySmooth;
uniform float isSneakingSmooth;

uniform sampler2D colortex0;
uniform sampler2D colortex1;
uniform sampler2D colortex2;
uniform sampler2D colortex3;
uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform sampler2D colortex8;
uniform sampler2D colortex9;
uniform sampler2D colortex10;
uniform sampler2D colortex12;
uniform sampler2D depthtex0;
uniform sampler2D depthtex1;
uniform sampler2D depthtex2;
uniform sampler2D noisetex;
uniform sampler2D colortex13;
uniform sampler2D colortex14;
uniform sampler2D colortex15;

float LinearToCurve(float c) {
    return pow(c, 0.25f);
}

float CurveToLinear(float c) {
    c = c * c;
    return c * c;
}

vec3 LinearToCurve(vec3 c) {
    return pow(c, vec3(0.25f));
}

vec3 CurveToLinear(vec3 c) {
    c = c * c;
    return c * c;
}

vec2 OctWrap(vec2 v) {
    return (1.0f - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}

float D_Walter(float NdotH, float roughness) {
    float roughness2 = roughness * roughness;
    float k = NdotH * NdotH * (roughness2 - 1.0f) + 1.0f;
    return roughness2 / (3.14159265359f * k * k);
}

float F_Schlick(float VdotH, float f0, float f90) {
    VdotH = 1.0f - VdotH;
    float VdotH2 = VdotH * VdotH;
    return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}

vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
    VdotH = 1.0f - VdotH;
    float VdotH2 = VdotH * VdotH;
    return f0 + (1.0f - f0) * (VdotH2 * VdotH2 * VdotH);
}

float V_Schlick(float NdotL, float NdotV, float roughness) {
    float k = roughness * 0.5f;
    return NdotL / ((NdotL * (1.0f - k) + k) * (NdotV * (1.0f - k) + k) + 1.0E-20f);
}

float bayer2(vec2 a) {
    a = floor(a);
    return fract(dot(a, vec2(0.5f, a.y * 0.75f)));
}

float bayer4(vec2 a) {
    return bayer2(0.5f * a) * 0.25f + bayer2(a);
}

float bayer8(vec2 a) {
    return bayer4(0.5f * a) * 0.25f + bayer2(a);
}

float bayer16(vec2 a) {
    return bayer4(0.25f * a) * 0.0625f + bayer4(a);
}

layout(local_size_x = 16, local_size_y = 8) in;
writeonly layout(rgba16f) uniform highp image2D colorimg2;

const vec2 workGroupsRender = vec2(0.35f, 0.25f);

vec3 AxialGaussianBlurY(
    sampler2D texSampler,
    vec2 coord,
    float coordScale,
    float coordOffset,
    float sampleOrigin,
    vec2 sampleSize,
    const float alpha,
    const float steps
) {
    vec3 blur = vec3(0.0f);
    float weights = 0.0f;
    for (float i = -steps; i <= steps; i++) {
        float sampleWeight = exp2(-i * i * alpha * 5.77f);
        vec2 sampleCoord = coord;
        sampleCoord.y += 2.0f / coordScale * pixelSize.y * i;
        vec2 tCoord = sampleCoord;
        sampleCoord = clamp(sampleCoord, vec2(sampleOrigin, 0.0f), vec2(sampleOrigin + sampleSize.x, sampleSize.y));
        sampleWeight *= float(all(equal(tCoord, sampleCoord))) + 1.0E-20f;
        sampleCoord.y = sampleCoord.y * coordScale + coordOffset;
        blur += textureLod(texSampler, sampleCoord, 0.0f).rgb * sampleWeight;
        weights += sampleWeight;
    }
    return blur / weights;
}

void main() {
    vec2 originSize = vec2(0.25f);
    vec2 borderWidth = pixelSize;
    const float intervalWidth = 3.0f;
    vec2 border = originSize + borderWidth;
    vec2 axis = vec2(0.0f, 1.0f);
    vec3 blur = vec3(0.0f);

    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    texelCoord.x += int(screenSize.x * 0.25f);
    vec2 texCoord = (vec2(texelCoord) + 0.5f) * pixelSize;

    float coordOffset = (floor(screenSize.y * 0.5f) + 1.0f) * pixelSize.y;
    vec2 coord = texCoord;
    float currInterval = 0.0f;
    float sampleOrigin = 0.0f;

    currInterval = originSize.x + pixelSize.x * intervalWidth;
    coord.x -= currInterval;
    sampleOrigin += currInterval;
    originSize *= 0.5f;
    border = originSize + borderWidth;
    if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurY(colortex2, texCoord, 2.0f, coordOffset, sampleOrigin, originSize, 0.16f, 2.0f);
    }

    currInterval = originSize.x + pixelSize.x * intervalWidth;
    coord.x -= currInterval;
    sampleOrigin += currInterval;
    originSize *= 0.5f;
    border = originSize + borderWidth;
    if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurY(colortex2, texCoord, 4.0f, coordOffset, sampleOrigin, originSize, 0.035f, 5.0f);
    }

    currInterval = originSize.x + pixelSize.x * intervalWidth;
    coord.x -= currInterval;
    sampleOrigin += currInterval;
    originSize *= 0.5f;
    border = originSize + borderWidth;
    if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurY(colortex2, texCoord, 8.0f, coordOffset, sampleOrigin, originSize, 0.0085f, 12.0f);
    }

    currInterval = originSize.x + pixelSize.x * intervalWidth;
    coord.x -= currInterval;
    sampleOrigin += currInterval;
    originSize *= 0.5f;
    border = originSize + borderWidth;
    if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurY(colortex2, texCoord, 16.0f, coordOffset, sampleOrigin, originSize, 0.002f, 28.0f);
    }

    currInterval = originSize.x + pixelSize.x * intervalWidth;
    coord.x -= currInterval;
    sampleOrigin += currInterval;
    originSize *= 0.5f;
    border = originSize + borderWidth;
    if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurY(colortex2, texCoord, 32.0f, coordOffset, sampleOrigin, originSize, 5.0E-4f, 50.0f);
    }

    currInterval = originSize.x + pixelSize.x * intervalWidth;
    coord.x -= currInterval;
    sampleOrigin += currInterval;
    originSize *= 0.5f;
    border = originSize + borderWidth;
    if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurY(colortex2, texCoord, 64.0f, coordOffset, sampleOrigin, originSize, 1.5E-4f, 90.0f);
    }

    imageStore(colorimg2, texelCoord, vec4(blur, 0.0f));
}
)";

const char* preConvertedGlsl5Original = R"(#version 430 core
// Generated by glsl-transformer
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;
struct iris_FogParameters {
vec4 color;
float density;
float start;
float end;
float scale;
};
iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0f / (iris_FogEnd - iris_FogStart));
uniform int heldItemId;
uniform int heldBlockLightValue;
uniform int heldItemId2;
uniform int heldBlockLightValue2;
uniform int worldTime;
uniform int frameCounter;
uniform float frameTime;
uniform float frameTimeCounter;
uniform float sunAngle;
uniform float aspectRatio;
uniform float viewWidth;
uniform float viewHeight;
uniform float near;
uniform float far;
uniform vec3 cameraPosition;
uniform vec3 cameraPositionFract;
uniform vec3 cameraPositionToPrevious;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferPreviousModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferPreviousProjection;
uniform mat4 shadowProjection;
uniform mat4 shadowModelViewInverse;
uniform float wetness;
uniform ivec2 eyeBrightnessSmooth;
uniform int isEyeInWater;
uniform float nightVision;
uniform float blindness;
uniform int hideGUI;
uniform float darknessFactor;
uniform float darknessLightFactor;
uniform vec2 taaJitter;
uniform vec2 taaJitterToPrevious;
uniform vec2 screenSize;
uniform vec2 pixelSize;
uniform vec3 shadowModelView0;
uniform vec3 shadowModelView1;
uniform vec3 shadowModelView2;
uniform float eyeBrightnessSmoothCurved;
uniform float eyeBrightnessZeroSmooth;
uniform float eyeSnowySmooth;
uniform float eyeNoPrecipitationSmooth;
uniform float eyeRxSmooth;
uniform float eyeRySmooth;
uniform float isSneakingSmooth;
uniform sampler2D colortex0;
uniform sampler2D colortex1;
uniform sampler2D colortex2;
uniform sampler2D colortex3;
uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform sampler2D colortex8;
uniform sampler2D colortex9;
uniform sampler2D colortex10;
uniform sampler2D colortex12;
uniform sampler2D depthtex0;
uniform sampler2D depthtex1;
uniform sampler2D depthtex2;
uniform sampler2D noisetex;
uniform sampler2D colortex13;
uniform sampler2D colortex14;
uniform sampler2D colortex15;
float LinearToCurve(float c) {
return pow(c, 0.25f);
}
float CurveToLinear(float c) {
c = c * c;
return c * c;
}
vec3 LinearToCurve(vec3 c) {
return pow(c, vec3(0.25f));
}
vec3 CurveToLinear(vec3 c) {
c = c * c;
return c * c;
}
vec2 OctWrap(vec2 v) {
return (1.0f - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}
float D_Walter(float NdotH, float roughness) {
float roughness2 = roughness * roughness;
float k = NdotH * NdotH * (roughness2 - 1.0f) + 1.0f;
return roughness2 / (3.14159265359f * k * k);
}
float F_Schlick(float VdotH, float f0, float f90) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}
vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (1.0f - f0) * (VdotH2 * VdotH2 * VdotH);
}
float V_Schlick(float NdotL, float NdotV, float roughness) {
float k = roughness * 0.5f;
return NdotL / ((NdotL * (1.0f - k) + k) * (NdotV * (1.0f - k) + k) + 1.0E-20f);
}
float bayer2(vec2 a) {
a = floor(a);
return fract(dot(a, vec2(0.5f, a.y * 0.75f)));
}
float bayer4(vec2 a) {
return bayer2(0.5f * a) * 0.25f + bayer2(a);
}
float bayer8(vec2 a) {
return bayer4(0.5f * a) * 0.25f + bayer2(a);
}
float bayer16(vec2 a) {
return bayer4(0.25f * a) * 0.0625f + bayer4(a);
}
layout(local_size_x = 16, local_size_y = 8) in;
layout(rgba16) uniform image2D colorimg2;
const vec2 workGroupsRender = vec2(0.35f, 0.25f);
vec3 AxialGaussianBlurY(
sampler2D texSampler,
vec2 coord,
float coordScale,
float coordOffset,
float sampleOrigin,
vec2 sampleSize,
const float alpha,
const float steps
) {
vec3 blur = vec3(0.0f);
float weights = 0.0f;
for (float i = -steps; i <= steps; i++) {
float sampleWeight = exp2(-i * i * alpha * 5.77f);
vec2 sampleCoord = coord;
sampleCoord.y += 2.0f / coordScale * pixelSize.y * i;
vec2 tCoord = sampleCoord;
sampleCoord = clamp(sampleCoord, vec2(sampleOrigin, 0.0f), vec2(sampleOrigin + sampleSize.x, sampleSize.y));
sampleWeight *= float(tCoord == sampleCoord) + 1.0E-20f;
sampleCoord.y = sampleCoord.y * coordScale + coordOffset;
blur += textureLod(texSampler, sampleCoord, 0.0f).rgb * sampleWeight;
weights += sampleWeight;
}
return blur / weights;
}
void main() {
vec2 originSize = vec2(0.25f);
vec2 borderWidth = pixelSize;
const float intervalWidth = 3.0f;
vec2 border = originSize + borderWidth;
vec2 axis = vec2(0.0f, 1.0f);
vec3 blur = vec3(0.0f);
ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
texelCoord.x += int(screenSize.x * 0.25f);
vec2 texCoord = (vec2(texelCoord) + 0.5f) * pixelSize;
float coordOffset = (floor(screenSize.y * 0.5f) + 1.0f) * pixelSize.y;
vec2 coord = texCoord;
float currInterval = 0.0f;
float sampleOrigin = 0.0f;
currInterval = originSize.x + pixelSize.x * intervalWidth;
coord.x -= currInterval;
sampleOrigin += currInterval;
originSize *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurY(colortex2, texCoord, 2.0f, coordOffset, sampleOrigin, originSize, 0.16f, 2.0f);
}
currInterval = originSize.x + pixelSize.x * intervalWidth;
coord.x -= currInterval;
sampleOrigin += currInterval;
originSize *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurY(colortex2, texCoord, 4.0f, coordOffset, sampleOrigin, originSize, 0.035f, 5.0f);
}
currInterval = originSize.x + pixelSize.x * intervalWidth;
coord.x -= currInterval;
sampleOrigin += currInterval;
originSize *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurY(colortex2, texCoord, 8.0f, coordOffset, sampleOrigin, originSize, 0.0085f, 12.0f);
}
currInterval = originSize.x + pixelSize.x * intervalWidth;
coord.x -= currInterval;
sampleOrigin += currInterval;
originSize *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurY(colortex2, texCoord, 16.0f, coordOffset, sampleOrigin, originSize, 0.002f, 28.0f);
}
currInterval = originSize.x + pixelSize.x * intervalWidth;
coord.x -= currInterval;
sampleOrigin += currInterval;
originSize *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurY(colortex2, texCoord, 32.0f, coordOffset, sampleOrigin, originSize, 5.0E-4f, 50.0f);
}
currInterval = originSize.x + pixelSize.x * intervalWidth;
coord.x -= currInterval;
sampleOrigin += currInterval;
originSize *= 0.5f;
border = originSize + borderWidth;
if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
blur = AxialGaussianBlurY(colortex2, texCoord, 64.0f, coordOffset, sampleOrigin, originSize, 1.5E-4f, 90.0f);
}
imageStore(colorimg2, texelCoord, vec4(blur, 0.0f));
})";

const char* preConvertedGlsl5Converted = R"(#version 320 es
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp image2D;

uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;

struct iris_FogParameters {
    vec4 color;
    float density;
    float start;
    float end;
    float scale;
};

iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0 / (iris_FogEnd - iris_FogStart));

uniform int heldItemId;
uniform int heldBlockLightValue;
uniform int heldItemId2;
uniform int heldBlockLightValue2;
uniform int worldTime;
uniform int frameCounter;
uniform float frameTime;
uniform float frameTimeCounter;
uniform float sunAngle;
uniform float aspectRatio;
uniform float viewWidth;
uniform float viewHeight;
uniform float near;
uniform float far;
uniform vec3 cameraPosition;
uniform vec3 cameraPositionFract;
uniform vec3 cameraPositionToPrevious;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferPreviousModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferPreviousProjection;
uniform mat4 shadowProjection;
uniform mat4 shadowModelViewInverse;
uniform float wetness;
uniform ivec2 eyeBrightnessSmooth;
uniform int isEyeInWater;
uniform float nightVision;
uniform float blindness;
uniform int hideGUI;
uniform float darknessFactor;
uniform float darknessLightFactor;
uniform vec2 taaJitter;
uniform vec2 taaJitterToPrevious;
uniform vec2 screenSize;
uniform vec2 pixelSize;
uniform vec3 shadowModelView0;
uniform vec3 shadowModelView1;
uniform vec3 shadowModelView2;
uniform float eyeBrightnessSmoothCurved;
uniform float eyeBrightnessZeroSmooth;
uniform float eyeSnowySmooth;
uniform float eyeNoPrecipitationSmooth;
uniform float eyeRxSmooth;
uniform float eyeRySmooth;
uniform float isSneakingSmooth;

uniform sampler2D colortex0;
uniform sampler2D colortex1;
uniform sampler2D colortex2;
uniform sampler2D colortex3;
uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform sampler2D colortex8;
uniform sampler2D colortex9;
uniform sampler2D colortex10;
uniform sampler2D colortex12;
uniform sampler2D depthtex0;
uniform sampler2D depthtex1;
uniform sampler2D depthtex2;
uniform sampler2D noisetex;
uniform sampler2D colortex13;
uniform sampler2D colortex14;
uniform sampler2D colortex15;

float LinearToCurve(float c) {
    return pow(c, 0.25);
}

float CurveToLinear(float c) {
    c = c * c;
    return c * c;
}

vec3 LinearToCurve(vec3 c) {
    return pow(c, vec3(0.25));
}

vec3 CurveToLinear(vec3 c) {
    c = c * c;
    return c * c;
}

vec2 OctWrap(vec2 v) {
    return (1.0 - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}

float D_Walter(float NdotH, float roughness) {
    float roughness2 = roughness * roughness;
    float k = NdotH * NdotH * (roughness2 - 1.0) + 1.0;
    return roughness2 / (3.14159265359 * k * k);
}

float F_Schlick(float VdotH, float f0, float f90) {
    VdotH = 1.0 - VdotH;
    float VdotH2 = VdotH * VdotH;
    return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}

vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
    VdotH = 1.0 - VdotH;
    float VdotH2 = VdotH * VdotH;
    return f0 + (1.0 - f0) * (VdotH2 * VdotH2 * VdotH);
}

float V_Schlick(float NdotL, float NdotV, float roughness) {
    float k = roughness * 0.5;
    return NdotL / ((NdotL * (1.0 - k) + k) * (NdotV * (1.0 - k) + k) + 1.0e-20);
}

float bayer2(vec2 a) {
    a = floor(a);
    return fract(dot(a, vec2(0.5, a.y * 0.75)));
}

float bayer4(vec2 a) {
    return bayer2(0.5 * a) * 0.25 + bayer2(a);
}

float bayer8(vec2 a) {
    return bayer4(0.5 * a) * 0.25 + bayer2(a);
}

float bayer16(vec2 a) {
    return bayer4(0.25 * a) * 0.0625 + bayer4(a);
}

layout(local_size_x = 16, local_size_y = 8) in;
layout(rgba16f) uniform highp image2D colorimg2;

const vec2 workGroupsRender = vec2(0.35, 0.25);

vec3 AxialGaussianBlurY(
    sampler2D texSampler,
    vec2 coord,
    float coordScale,
    float coordOffset,
    float sampleOrigin,
    vec2 sampleSize,
    const float alpha,
    const float steps
) {
    vec3 blur = vec3(0.0);
    float weights = 0.0;
    for (float i = -steps; i <= steps; i++) {
        float sampleWeight = exp2(-i * i * alpha * 5.77);
        vec2 sampleCoord = coord;
        sampleCoord.y += 2.0 / coordScale * pixelSize.y * i;
        vec2 tCoord = sampleCoord;
        sampleCoord = clamp(sampleCoord, vec2(sampleOrigin, 0.0), vec2(sampleOrigin + sampleSize.x, sampleSize.y));
        sampleWeight *= float(tCoord == sampleCoord) + 1.0e-20;
        sampleCoord.y = sampleCoord.y * coordScale + coordOffset;
        blur += textureLod(texSampler, sampleCoord, 0.0).rgb * sampleWeight;
        weights += sampleWeight;
    }
    return blur / weights;
}

void main() {
    vec2 originSize = vec2(0.25);
    vec2 borderWidth = pixelSize;
    const float intervalWidth = 3.0;
    vec2 border = originSize + borderWidth;
    vec2 axis = vec2(0.0, 1.0);
    vec3 blur = vec3(0.0);
    
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    texelCoord.x += int(screenSize.x * 0.25);
    vec2 texCoord = (vec2(texelCoord) + 0.5) * pixelSize;
    
    float coordOffset = (floor(screenSize.y * 0.5) + 1.0) * pixelSize.y;
    vec2 coord = texCoord;
    float currInterval = 0.0;
    float sampleOrigin = 0.0;

    currInterval = originSize.x + pixelSize.x * intervalWidth;
    coord.x -= currInterval;
    sampleOrigin += currInterval;
    originSize *= 0.5;
    border = originSize + borderWidth;
    if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurY(colortex2, texCoord, 2.0, coordOffset, sampleOrigin, originSize, 0.16, 2.0);
    }

    currInterval = originSize.x + pixelSize.x * intervalWidth;
    coord.x -= currInterval;
    sampleOrigin += currInterval;
    originSize *= 0.5;
    border = originSize + borderWidth;
    if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurY(colortex2, texCoord, 4.0, coordOffset, sampleOrigin, originSize, 0.035, 5.0);
    }

    currInterval = originSize.x + pixelSize.x * intervalWidth;
    coord.x -= currInterval;
    sampleOrigin += currInterval;
    originSize *= 0.5;
    border = originSize + borderWidth;
    if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurY(colortex2, texCoord, 8.0, coordOffset, sampleOrigin, originSize, 0.0085, 12.0);
    }

    currInterval = originSize.x + pixelSize.x * intervalWidth;
    coord.x -= currInterval;
    sampleOrigin += currInterval;
    originSize *= 0.5;
    border = originSize + borderWidth;
    if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurY(colortex2, texCoord, 16.0, coordOffset, sampleOrigin, originSize, 0.002, 28.0);
    }

    currInterval = originSize.x + pixelSize.x * intervalWidth;
    coord.x -= currInterval;
    sampleOrigin += currInterval;
    originSize *= 0.5;
    border = originSize + borderWidth;
    if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurY(colortex2, texCoord, 32.0, coordOffset, sampleOrigin, originSize, 0.0005, 50.0);
    }

    currInterval = originSize.x + pixelSize.x * intervalWidth;
    coord.x -= currInterval;
    sampleOrigin += currInterval;
    originSize *= 0.5;
    border = originSize + borderWidth;
    if (coord.x >= -borderWidth.x && coord.x <= border.x && coord.y <= border.y) {
        blur = AxialGaussianBlurY(colortex2, texCoord, 64.0, coordOffset, sampleOrigin, originSize, 0.00015, 90.0);
    }

    imageStore(colorimg2, texelCoord, vec4(blur, 0.0));
}
)";

const char* preConvertedGlsl6Original = R"(#version 430 core
// Generated by glsl-transformer
#extension GL_KHR_shader_subgroup_arithmetic: enable
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;
struct iris_FogParameters {
vec4 color;
float density;
float start;
float end;
float scale;
};
iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0f / (iris_FogEnd - iris_FogStart));
float LinearToCurve(float c) {
return pow(c, 0.25f);
}
float CurveToLinear(float c) {
c = c * c;
return c * c;
}
vec3 LinearToCurve(vec3 c) {
return pow(c, vec3(0.25f));
}
vec3 CurveToLinear(vec3 c) {
c = c * c;
return c * c;
}
vec2 OctWrap(vec2 v) {
return (1.0f - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}
float D_Walter(float NdotH, float roughness) {
float roughness2 = roughness * roughness;
float k = NdotH * NdotH * (roughness2 - 1.0f) + 1.0f;
return roughness2 / (3.14159265359f * k * k);
}
float F_Schlick(float VdotH, float f0, float f90) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}
vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (1.0f - f0) * (VdotH2 * VdotH2 * VdotH);
}
float V_Schlick(float NdotL, float NdotV, float roughness) {
float k = roughness * 0.5f;
return NdotL / ((NdotL * (1.0f - k) + k) * (NdotV * (1.0f - k) + k) + 1.0E-20f);
}
float bayer2(vec2 a) {
a = floor(a);
return fract(dot(a, vec2(0.5f, a.y * 0.75f)));
}
float bayer4(vec2 a) {
return bayer2(0.5f * a) * 0.25f + bayer2(a);
}
float bayer8(vec2 a) {
return bayer4(0.5f * a) * 0.25f + bayer2(a);
}
float bayer16(vec2 a) {
return bayer4(0.25f * a) * 0.0625f + bayer4(a);
}
uniform int heldItemId;
uniform int heldBlockLightValue;
uniform int heldItemId2;
uniform int heldBlockLightValue2;
uniform int worldTime;
uniform int frameCounter;
uniform float frameTime;
uniform float frameTimeCounter;
uniform float sunAngle;
uniform float aspectRatio;
uniform float viewWidth;
uniform float viewHeight;
uniform float near;
uniform float far;
uniform vec3 cameraPosition;
uniform vec3 cameraPositionFract;
uniform vec3 cameraPositionToPrevious;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferPreviousModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferPreviousProjection;
uniform mat4 shadowProjection;
uniform mat4 shadowModelViewInverse;
uniform float wetness;
uniform ivec2 eyeBrightnessSmooth;
uniform int isEyeInWater;
uniform float nightVision;
uniform float blindness;
uniform int hideGUI;
uniform float darknessFactor;
uniform float darknessLightFactor;
uniform vec2 taaJitter;
uniform vec2 taaJitterToPrevious;
uniform vec2 screenSize;
uniform vec2 pixelSize;
uniform vec3 shadowModelView0;
uniform vec3 shadowModelView1;
uniform vec3 shadowModelView2;
uniform float eyeBrightnessSmoothCurved;
uniform float eyeBrightnessZeroSmooth;
uniform float eyeSnowySmooth;
uniform float eyeNoPrecipitationSmooth;
uniform float eyeRxSmooth;
uniform float eyeRySmooth;
uniform float isSneakingSmooth;
uniform sampler2D colortex0;
uniform sampler2D colortex1;
uniform sampler2D colortex2;
uniform sampler2D colortex3;
uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform sampler2D colortex8;
uniform sampler2D colortex9;
uniform sampler2D colortex10;
uniform sampler2D colortex12;
uniform sampler2D depthtex0;
uniform sampler2D depthtex1;
uniform sampler2D depthtex2;
uniform sampler2D noisetex;
uniform sampler2D colortex13;
uniform sampler2D colortex14;
uniform sampler2D colortex15;
const ivec3 workGroups = ivec3(1, 2, 1);
layout(local_size_x = 512) in;
layout(rg16) uniform writeonly image2D img_rtwWarp1D;
shared float prefixSumCache[512];
uniform sampler2D rtwImportanceBlurred1D;
uniform bool rtwDiscardRefresh;
const float shadowDistance = 192.0f;
const float voxelDistance = 96.0f;
const float shadowSize = 3968.0f;
const float shadowPixelSize = 1.0f / 3968.0f;
const float shadowWidth = 2048.0f;
const float voxelWidth = 1920.0f;
const float shadowRatio = 16.0f / 31.0f;
void main() {
if (rtwDiscardRefresh) return;
ivec2 drawTexel = ivec2(gl_GlobalInvocationID.xy);
float importance = texelFetch(rtwImportanceBlurred1D, drawTexel, 0).x;
float shadowCoord = (float(drawTexel.x) + 0.5f) / 256.0f - 1.0f;
float voxelWeight = step(abs(shadowCoord), voxelDistance / shadowDistance) * 0.02f;
importance = max(importance, voxelWeight);
float prefixSum = subgroupInclusiveAdd(importance);
if (gl_SubgroupInvocationID == gl_SubgroupSize - 1u) prefixSumCache[gl_SubgroupID] = prefixSum;
barrier();
uint loopLength = uint(findMSB(gl_NumSubgroups));
loopLength += uint(gl_NumSubgroups - (1u << (loopLength - 1u)) > 0u);
for (uint i = 0; i < loopLength; i++) {
if ((gl_SubgroupID & (1u << i)) > 0u) {
prefixSum += prefixSumCache[(gl_SubgroupID >> i << i) - 1u];
if (gl_SubgroupInvocationID == gl_SubgroupSize - 1u) prefixSumCache[gl_SubgroupID] = prefixSum;
}
barrier();
}
if (gl_LocalInvocationID.x == 511u) prefixSumCache[0] = prefixSum;
barrier();
float sum = prefixSumCache[0];
float warp = (prefixSum - importance) / sum - float(gl_LocalInvocationID.x + 1u) / 512.0f;
warp = warp * 0.5f + 0.5f;
float warpPixelSize = importance / max(sum, 1.0f);
imageStore(img_rtwWarp1D, drawTexel, vec4(warp, warpPixelSize, 0.0f, 0.0f));
})";

const char* preConvertedGlsl6Converted = R"(#version 320 es
precision highp float;

uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;

layout(local_size_x = 512) in;

layout(rgba16f) uniform writeonly highp image2D img_rtwWarp1D;

shared float prefixSumCache[512];
uniform sampler2D rtwImportanceBlurred1D;
uniform bool rtwDiscardRefresh;

const float shadowDistance = 192.0f;
const float voxelDistance = 96.0f;
const float shadowSize = 3968.0f;
const float shadowPixelSize = 1.0f / 3968.0f;
const float shadowWidth = 2048.0f;
const float voxelWidth = 1920.0f;
const float shadowRatio = 16.0f / 31.0f;

void main() {
    if (rtwDiscardRefresh) return;
    ivec2 drawTexel = ivec2(gl_GlobalInvocationID.xy);
    float importance = texelFetch(rtwImportanceBlurred1D, drawTexel, 0).x;
    float shadowCoord = (float(drawTexel.x) + 0.5f) / 256.0f - 1.0f;
    float voxelWeight = step(abs(shadowCoord), voxelDistance / shadowDistance) * 0.02f;
    importance = max(importance, voxelWeight);
    
    // Calculate sum manually without subgroups
    float prefixSum = importance + importance;
    float sum = prefixSum;

    float warp = (prefixSum - importance) / sum - float(gl_LocalInvocationID.x + 1u) / 512.0f;
    warp = warp * 0.5f + 0.5f;
    float warpPixelSize = importance / max(sum, 1.0f);
    imageStore(img_rtwWarp1D, drawTexel, vec4(warp, warpPixelSize, 0.0f, 0.0f));
}

)";

const char* preConvertedGlsl7Original = R"(#version 430 core
// Generated by glsl-transformer
#extension GL_KHR_shader_subgroup_arithmetic: enable
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;
struct iris_FogParameters {
vec4 color;
float density;
float start;
float end;
float scale;
};
iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0f / (iris_FogEnd - iris_FogStart));
const ivec3 workGroups = ivec3(1, 1, 1);
layout(local_size_x = 32, local_size_y = 16) in;
float remapSaturate(float x, float e0, float e1) {
return clamp((x - e0) / (e1 - e0), 0.0f, 1.0f);
}
float LinearToCurve(float c) {
return pow(c, 0.25f);
}
float CurveToLinear(float c) {
c = c * c;
return c * c;
}
vec3 LinearToCurve(vec3 c) {
return pow(c, vec3(0.25f));
}
vec3 CurveToLinear(vec3 c) {
c = c * c;
return c * c;
}
vec2 OctWrap(vec2 v) {
return (1.0f - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}
float D_Walter(float NdotH, float roughness) {
float roughness2 = roughness * roughness;
float k = NdotH * NdotH * (roughness2 - 1.0f) + 1.0f;
return roughness2 / (3.14159265359f * k * k);
}
float F_Schlick(float VdotH, float f0, float f90) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}
vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
VdotH = 1.0f - VdotH;
float VdotH2 = VdotH * VdotH;
return f0 + (1.0f - f0) * (VdotH2 * VdotH2 * VdotH);
}
float V_Schlick(float NdotL, float NdotV, float roughness) {
float k = roughness * 0.5f;
return NdotL / ((NdotL * (1.0f - k) + k) * (NdotV * (1.0f - k) + k) + 1.0E-20f);
}
float bayer2(vec2 a) {
a = floor(a);
return fract(dot(a, vec2(0.5f, a.y * 0.75f)));
}
float bayer4(vec2 a) {
return bayer2(0.5f * a) * 0.25f + bayer2(a);
}
float bayer8(vec2 a) {
return bayer4(0.5f * a) * 0.25f + bayer2(a);
}
float bayer16(vec2 a) {
return bayer4(0.25f * a) * 0.0625f + bayer4(a);
}
uniform int heldItemId;
uniform int heldBlockLightValue;
uniform int heldItemId2;
uniform int heldBlockLightValue2;
uniform int worldTime;
uniform int frameCounter;
uniform float frameTime;
uniform float frameTimeCounter;
uniform float sunAngle;
uniform float aspectRatio;
uniform float viewWidth;
uniform float viewHeight;
uniform float near;
uniform float far;
uniform vec3 cameraPosition;
uniform vec3 cameraPositionFract;
uniform vec3 cameraPositionToPrevious;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferPreviousModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferPreviousProjection;
uniform mat4 shadowProjection;
uniform mat4 shadowModelViewInverse;
uniform float wetness;
uniform ivec2 eyeBrightnessSmooth;
uniform int isEyeInWater;
uniform float nightVision;
uniform float blindness;
uniform int hideGUI;
uniform float darknessFactor;
uniform float darknessLightFactor;
uniform vec2 taaJitter;
uniform vec2 taaJitterToPrevious;
uniform vec2 screenSize;
uniform vec2 pixelSize;
uniform vec3 shadowModelView0;
uniform vec3 shadowModelView1;
uniform vec3 shadowModelView2;
uniform float eyeBrightnessSmoothCurved;
uniform float eyeBrightnessZeroSmooth;
uniform float eyeSnowySmooth;
uniform float eyeNoPrecipitationSmooth;
uniform float eyeRxSmooth;
uniform float eyeRySmooth;
uniform float isSneakingSmooth;
uniform sampler2D colortex0;
uniform sampler2D colortex1;
uniform sampler2D colortex2;
uniform sampler2D colortex3;
uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform sampler2D colortex8;
uniform sampler2D colortex9;
uniform sampler2D colortex10;
uniform sampler2D colortex12;
uniform sampler2D depthtex0;
uniform sampler2D depthtex1;
uniform sampler2D depthtex2;
uniform sampler2D noisetex;
uniform sampler2D colortex13;
uniform sampler2D colortex14;
uniform sampler2D colortex15;
layout(rgba16f) uniform image2D colorimg3;
shared vec2 prefixSumCache[512];
void main() {
vec2 texCoord = (vec2(gl_GlobalInvocationID.xy) + 0.5f) * vec2(1.0f / 32.0f, 1.0f / 16.0f);
vec2 sampleCoord = texCoord * (1.0f / 64.0f);
sampleCoord.x += (15.0f / 32.0f) + pixelSize.x * 12.0f;
float tileExposure = dot(textureLod(colortex2, sampleCoord, 0.0f).rgb, vec3(0.2125f, 0.7154f, 0.0721f));
vec2 sampleLuminance = vec2(tileExposure, 0.0f);
sampleLuminance = subgroupInclusiveAdd(sampleLuminance);
if (gl_SubgroupInvocationID == gl_SubgroupSize - 1u) prefixSumCache[gl_SubgroupID] = sampleLuminance;
barrier();
uint loopLength = uint(findMSB(gl_NumSubgroups));
loopLength += uint(gl_NumSubgroups - (1u << (loopLength - 1u)) > 0u);
for (uint i = 0; i < loopLength; i++) {
if ((gl_SubgroupID & (1u << i)) > 0u) {
sampleLuminance += prefixSumCache[(gl_SubgroupID >> i << i) - 1u];
if (gl_SubgroupInvocationID == gl_SubgroupSize - 1u) prefixSumCache[gl_SubgroupID] = sampleLuminance;
}
barrier();
}
if (gl_LocalInvocationIndex.x == 511u) prefixSumCache[0] = sampleLuminance / 512.0f;
;
barrier();
float avg = prefixSumCache[0].x;
vec2 tileDistance = texCoord * 2.0f - 1.0f;
tileDistance.y /= aspectRatio;
float centerDistance = length(tileDistance);
float tileWeight = remapSaturate(centerDistance, 0.6f, 0.4f);
tileExposure = max(7.0E-7f, tileExposure);
float lumaWeight = avg / tileExposure;
lumaWeight = pow(lumaWeight, remapSaturate(avg, 0.02f, 0.001f) * 0.6f);
tileWeight *= lumaWeight;
vec2 sampleExposure = vec2(tileExposure * tileWeight, tileWeight);
sampleExposure = subgroupInclusiveAdd(sampleExposure);
if (gl_SubgroupInvocationID == gl_SubgroupSize - 1u) prefixSumCache[gl_SubgroupID] = sampleExposure;
barrier();
for (uint i = 0; i < loopLength; i++) {
if ((gl_SubgroupID & (1u << i)) > 0u) {
sampleExposure += prefixSumCache[(gl_SubgroupID >> i << i) - 1u];
if (gl_SubgroupInvocationID == gl_SubgroupSize - 1u) prefixSumCache[gl_SubgroupID] = sampleExposure;
}
barrier();
}
if (gl_LocalInvocationIndex.x == 511u) {
float avgExposure = sampleExposure.x / sampleExposure.y;
avgExposure = max(avgExposure * 100.0f, 1.0E-5f);
vec4 data3 = texelFetch(colortex3, ivec2(0), 0);
float prevAvgExposure = data3.a;
float frameTimeFixed = frameTime + step(frameTime, 0.0f) * 5.0f;
float exposureTime = clamp((step(avgExposure, prevAvgExposure) * 2.0f + 1.0f) * frameTimeFixed / 1.0f, 0.0f, 1.0f);
avgExposure = mix(prevAvgExposure, avgExposure, exposureTime);
data3.a = avgExposure;
imageStore(colorimg3, ivec2(0), data3);
}
})";

const char* preConvertedGlsl7Converted = R"(#version 320 es
precision highp float;

uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;
layout(local_size_x = 32, local_size_y = 16) in;

float remapSaturate(float x, float e0, float e1) {
    return clamp((x - e0) / (e1 - e0), 0.0f, 1.0f);
}

float LinearToCurve(float c) {
    return pow(c, 0.25f);
}

float CurveToLinear(float c) {
    c = c * c;
    return c * c;
}

vec3 LinearToCurve(vec3 c) {
    return pow(c, vec3(0.25f));
}

vec3 CurveToLinear(vec3 c) {
    c = c * c;
    return c * c;
}

vec2 OctWrap(vec2 v) {
    return (1.0f - abs(v.yx)) * uintBitsToFloat((floatBitsToUint(v.xy) & 0x80000000u) | 0x3f800000u);
}

float D_Walter(float NdotH, float roughness) {
    float roughness2 = roughness * roughness;
    float k = NdotH * NdotH * (roughness2 - 1.0f) + 1.0f;
    return roughness2 / (3.14159265359f * k * k);
}

float F_Schlick(float VdotH, float f0, float f90) {
    VdotH = 1.0f - VdotH;
    float VdotH2 = VdotH * VdotH;
    return f0 + (f90 - f0) * VdotH2 * VdotH2 * VdotH;
}

vec3 F_Schlick_Reflection(float VdotH, vec3 f0) {
    VdotH = 1.0f - VdotH;
    float VdotH2 = VdotH * VdotH;
    return f0 + (1.0f - f0) * (VdotH2 * VdotH2 * VdotH);
}

float V_Schlick(float NdotL, float NdotV, float roughness) {
    float k = roughness * 0.5f;
    return NdotL / ((NdotL * (1.0f - k) + k) * (NdotV * (1.0f - k) + k) + 1.0E-20f);
}

float bayer2(vec2 a) {
    a = floor(a);
    return fract(dot(a, vec2(0.5f, a.y * 0.75f)));
}

float bayer4(vec2 a) {
    return bayer2(0.5f * a) * 0.25f + bayer2(a);
}

float bayer8(vec2 a) {
    return bayer4(0.5f * a) * 0.25f + bayer2(a);
}

float bayer16(vec2 a) {
    return bayer4(0.25f * a) * 0.0625f + bayer4(a);
}

uniform int heldItemId;
uniform int heldBlockLightValue;
uniform int heldItemId2;
uniform int heldBlockLightValue2;
uniform int worldTime;
uniform int frameCounter;
uniform float frameTime;
uniform float frameTimeCounter;
uniform float sunAngle;
uniform float aspectRatio;
uniform float viewWidth;
uniform float viewHeight;
uniform float near;
uniform float far;
uniform vec3 cameraPosition;
uniform vec3 cameraPositionFract;
uniform vec3 cameraPositionToPrevious;
uniform mat4 gbufferModelView;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferPreviousModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferPreviousProjection;
uniform mat4 shadowProjection;
uniform mat4 shadowModelViewInverse;
uniform float wetness;
uniform ivec2 eyeBrightnessSmooth;
uniform int isEyeInWater;
uniform float nightVision;
uniform float blindness;
uniform int hideGUI;
uniform float darknessFactor;
uniform float darknessLightFactor;
uniform vec2 taaJitter;
uniform vec2 taaJitterToPrevious;
uniform vec2 screenSize;
uniform vec2 pixelSize;
uniform vec3 shadowModelView0;
uniform vec3 shadowModelView1;
uniform vec3 shadowModelView2;
uniform float eyeBrightnessSmoothCurved;
uniform float eyeBrightnessZeroSmooth;
uniform float eyeSnowySmooth;
uniform float eyeNoPrecipitationSmooth;
uniform float eyeRxSmooth;
uniform float eyeRySmooth;
uniform float isSneakingSmooth;
uniform sampler2D colortex0;
uniform sampler2D colortex1;
uniform sampler2D colortex2;
uniform sampler2D colortex3;
uniform sampler2D colortex4;
uniform sampler2D colortex5;
uniform sampler2D colortex6;
uniform sampler2D colortex8;
uniform sampler2D colortex9;
uniform sampler2D colortex10;
uniform sampler2D colortex12;
uniform sampler2D depthtex0;
uniform sampler2D depthtex1;
uniform sampler2D depthtex2;
uniform sampler2D noisetex;
uniform sampler2D colortex13;
uniform sampler2D colortex14;
uniform sampler2D colortex15;
writeonly layout(rgba16f) uniform highp image2D colorimg3;

void main() {
    vec2 texCoord = (vec2(gl_GlobalInvocationID.xy) + 0.5f) * vec2(1.0f / 32.0f, 1.0f / 16.0f);
    vec2 sampleCoord = texCoord * (1.0f / 64.0f);
    sampleCoord.x += (15.0f / 32.0f) + pixelSize.x * 12.0f;
    float tileExposure = dot(textureLod(colortex2, sampleCoord, 0.0f).rgb, vec3(0.2125f, 0.7154f, 0.0721f));
    vec2 sampleLuminance = vec2(tileExposure, 0.0f);
    
    // Calculate sum manually without subgroups
    sampleLuminance += sampleLuminance; // Simulate inclusive sum
    float avg = sampleLuminance.x;
    
    vec2 tileDistance = texCoord * 2.0f - 1.0f;
    tileDistance.y /= aspectRatio;
    float centerDistance = length(tileDistance);
    float tileWeight = remapSaturate(centerDistance, 0.6f, 0.4f);
    tileExposure = max(7.0E-7f, tileExposure);
    float lumaWeight = avg / tileExposure;
    lumaWeight = pow(lumaWeight, remapSaturate(avg, 0.02f, 0.001f) * 0.6f);
    tileWeight *= lumaWeight;
    vec2 sampleExposure = vec2(tileExposure * tileWeight, tileWeight);

    float avgExposure = sampleExposure.x / sampleExposure.y;
    avgExposure = max(avgExposure * 100.0f, 1.0E-5f);
    vec4 data3 = texelFetch(colortex3, ivec2(0), 0);
    float prevAvgExposure = data3.a;
    float frameTimeFixed = frameTime + step(frameTime, 0.0f) * 5.0f;
    float exposureTime = clamp((step(avgExposure, prevAvgExposure) * 2.0f + 1.0f) * frameTimeFixed / 1.0f, 0.0f, 1.0f);
    avgExposure = mix(prevAvgExposure, avgExposure, exposureTime);
    data3.a = avgExposure;
    imageStore(colorimg3, ivec2(0), data3);
}
)";

int calculateLevenshteinDistance(const char* str1, const char* str2) {
    if (!str1 || !str2)
        return 0;
    int len1 = std::strlen(str1);
    int len2 = std::strlen(str2);

    std::vector<int> prev(len2 + 1);
    std::vector<int> curr(len2 + 1);

    for (int j = 0; j <= len2; ++j) {
        prev[j] = j;
    }

    for (int i = 1; i <= len1; ++i) {
        curr[0] = i;
        for (int j = 1; j <= len2; ++j) {
            int cost = (str1[i - 1] == str2[j - 1]) ? 0 : 1;
            curr[j] = std::min({ prev[j] + 1,
                                 curr[j - 1] + 1,
                                 prev[j - 1] + cost
                               });
        }
        prev.swap(curr);
    }

    return prev[len2];
}

// TODO: improve the performance
int calculateSimilarity(const char* str1, const char* str2) {
    if (!str1 || !str2)
        return 0;
    int len1 = std::strlen(str1);
    int len2 = std::strlen(str2);
    if (len1 == 0 && len2 == 0) {
        return 100; 
    }
    int distance = calculateLevenshteinDistance(str1, str2);
    int maxLen = std::max(len1, len2);
    int similarity = static_cast<int>((1.0 - static_cast<double>(distance) / maxLen) * 100);

    return similarity;
}

// TODO: improve the performance
char* preConvertedGlsl(char* glsl_code) {
    // pre-converted glsl 1
    int similarity1 = calculateSimilarity(glsl_code,preConvertedGlsl1Original);
    LOG_D("similarity1: %d", similarity1)
    if (similarity1 > 95) {
        return (char*)preConvertedGlsl1Converted;
    }

    // pre-converted glsl 2
    int similarity2 = calculateSimilarity(glsl_code,preConvertedGlsl2Original);
    LOG_D("similarity2: %d", similarity2)
    if (similarity2 > 95) {
        return (char*)preConvertedGlsl2Converted;
    }

    // pre-converted glsl 3
    int similarity3 = calculateSimilarity(glsl_code,preConvertedGlsl3Original);
    LOG_D("similarity3: %d", similarity3)
    if (similarity3 > 95) {
        return (char*)preConvertedGlsl3Converted;
    }

    // pre-converted glsl 4
    int similarity4 = calculateSimilarity(glsl_code,preConvertedGlsl4Original);
    LOG_D("similarity4: %d", similarity4)
    if (similarity4 > 95) {
        return (char*)preConvertedGlsl4Converted;
    }

    // pre-converted glsl 5
    int similarity5 = calculateSimilarity(glsl_code,preConvertedGlsl5Original);
    LOG_D("similarity5: %d", similarity5)
    if (similarity5 > 95) {
        return (char*)preConvertedGlsl5Converted;
    }

    // pre-converted glsl 6
    int similarity6 = calculateSimilarity(glsl_code,preConvertedGlsl6Original);
    LOG_D("similarity6: %d", similarity6)
    if (similarity6 > 96) {
        return (char*)preConvertedGlsl6Converted;
    }

    // pre-converted glsl 7
    int similarity7 = calculateSimilarity(glsl_code,preConvertedGlsl7Original);
    LOG_D("similarity7: %d", similarity7)
    if (similarity7 > 95) {
        return (char*)preConvertedGlsl7Converted;
    }
    return nullptr;
}